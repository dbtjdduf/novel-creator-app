<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>소설 짜깁기 v.1</title>
    
    <!-- 홈 화면 앱 기능 추가 -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0284c7">
    <!-- // 홈 화면 앱 기능 추가 -->

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .modal-content {
            max-height: 80vh;
        }
        .nav-button {
            padding: 0.5rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        .nav-button.active {
            background-color: #0ea5e9; /* sky-500 */
            color: white;
        }
        .nav-button:not(.active) {
            background-color: #e2e8f0; /* slate-200 */
            color: #475569; /* slate-600 */
        }
        .nav-button:not(.active):hover {
            background-color: #cbd5e1; /* slate-300 */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <!-- Chosen Palette: Slate Gray & Sky Blue -->
    <!-- Application Structure Plan: A 'Load from File' feature is added. The initial screen now has a 'Load' button which triggers a hidden file input. A FileReader reads the .txt file, and a robust parsing function using regular expressions extracts the full plot, summary, and all story logs (both summary and expanded versions). The application state is then fully restored, and the user is transitioned directly to the story creation view, ready to continue where they left off. -->
    <!-- Visualization & Content Choices: A new "기존작업 불러오기" button is added to the setup screen. The core of this feature is the `parseAndLoadState` JavaScript function, which uses regex to reliably parse the structured .txt file. This approach is superior to simple splitting as it correctly handles missing sections (like summary or expanded text for some chapters). The user experience is seamless: click, select file, and the app is instantly restored. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

    <div id="app" class="container mx-auto p-4 md:p-8 max-w-4xl">
        <input type="file" id="file-loader" class="hidden" accept=".txt">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900">소설 짜깁기 v.1</h1>
            <p class="text-lg text-gray-600 mt-2">designed by 유성열</p>
        </header>

        <!-- Generic Modal -->
        <div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center p-4">
            <div id="modal-content-area" class="bg-white p-6 md:p-8 rounded-lg shadow-xl w-full max-w-md md:max-w-3xl modal-content overflow-y-auto">
                <!-- Modal content will be injected here -->
            </div>
        </div>

        <nav id="main-nav" class="hidden mb-6 flex justify-center gap-4">
            <button onclick="showView('story-screen')" class="nav-button active">스토리 제작</button>
            <button onclick="showView('archive-screen')" class="nav-button">기록 보관소</button>
        </nav>

        <!-- 초기 설정 화면 -->
        <main id="setup-screen">
             <div class="bg-white p-6 rounded-lg shadow-md">
                <div class="text-center mb-8">
                    <button id="load-button" class="bg-gray-700 hover:bg-gray-800 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105 text-xl w-full max-w-xs mx-auto">
                        기존작업 불러오기
                    </button>
                </div>
                <div class="flex items-center text-center my-6">
                    <hr class="flex-grow border-gray-300">
                    <span class="mx-4 text-gray-500 font-semibold">또는</span>
                    <hr class="flex-grow border-gray-300">
                </div>

                <h2 class="text-2xl font-bold mb-6 text-center">새로운 스토리 시작하기</h2>
                <p class="text-center text-gray-500 mb-6 -mt-4">(다중 선택 가능)</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-6">
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-gray-700">1. 대표 장르</h3>
                        <div id="main-genre-options" class="grid grid-cols-2 sm:grid-cols-3 gap-2"></div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-gray-700">2. 세부 장르</h3>
                        <div id="sub-genre-options" class="grid grid-cols-2 sm:grid-cols-3 gap-2"></div>
                    </div>
                     <div>
                        <h3 class="text-xl font-semibold mb-3 text-gray-700">3. 주인공 타입</h3>
                        <div id="protagonist-type-options" class="grid grid-cols-2 sm:grid-cols-3 gap-2"></div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-gray-700">4. 주인공 초기 특성</h3>
                        <div id="protagonist-trait-options" class="grid grid-cols-2 sm:grid-cols-3 gap-2"></div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-gray-700">5. 세계관 배경</h3>
                        <div id="world-bg-options" class="grid grid-cols-2 sm:grid-cols-3 gap-2"></div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-gray-700">6. 핵심 시스템</h3>
                        <div id="world-system-options" class="grid grid-cols-2 sm:grid-cols-3 gap-2"></div>
                    </div>
                </div>
                <div class="mt-10 text-center">
                    <button id="start-button" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105 text-xl">
                        이세계로 출발
                    </button>
                </div>
            </div>
        </main>

        <!-- 스토리 진행 화면 -->
        <main id="story-screen" class="hidden">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-bold mb-4 text-center border-b pb-4">스토리 로그</h2>
                <p id="summary-status" class="text-center text-sm text-sky-600 mb-4 hidden"></p>
                <div id="story-log" class="min-h-[150px] bg-gray-50 p-4 rounded-md border mb-6 space-y-2 text-gray-700"></div>

                <h3 class="text-xl font-semibold mb-4 text-center">다음 이야기를 선택하세요.</h3>
                <div id="loader" class="flex justify-center items-center my-4 hidden">
                    <div class="spinner"></div>
                    <p class="ml-4 text-gray-600">AI가 생각 중입니다...</p>
                </div>
                <div id="choices-container" class="space-y-4 mb-6"></div>
                
                <div class="border-t pt-6">
                     <h3 class="text-lg font-semibold mb-3 text-center text-gray-700">위 선택지가 마음에 들지 않나요?</h3>
                     <p class="text-center text-gray-500 mb-4">원하는 다음 상황을 직접 입력해보세요.</p>
                     <div class="flex flex-col sm:flex-row gap-2">
                        <input type="text" id="custom-input" class="flex-grow w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500" placeholder="예: 갑자기 하늘에서 검이 떨어진다.">
                        <button id="custom-submit-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-md transition-colors">
                            제출
                        </button>
                     </div>
                </div>

                <div class="mt-10 flex flex-wrap justify-center items-center gap-4">
                    <button id="generate-full-plot-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 text-lg hidden">
                        전체 스토리 생성/확인
                    </button>
                     <button id="summarize-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 text-lg">
                        현재까지 내용 요약하기
                    </button>
                    <button id="expand-story-button" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 text-lg">
                        스토리 부풀리기
                    </button>
                     <button id="save-button" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 text-lg">
                        스토리 기록하기
                    </button>
                </div>
            </div>
        </main>

        <!-- 기록 보관소 화면 -->
        <main id="archive-screen" class="hidden">
             <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-bold mb-6 text-center border-b pb-4">기록 보관소</h2>
                <div id="archive-content">
                    <h3 class="text-xl font-semibold mb-4 text-gray-800">전체 줄거리</h3>
                    <div id="archive-full-plot" class="whitespace-pre-wrap bg-gray-50 p-4 rounded-md border mb-8 min-h-[100px]"></div>
                    <h3 class="text-xl font-semibold mb-4 text-gray-800">상세 스토리 로그</h3>
                    <div id="archive-story-log" class="bg-gray-50 p-4 rounded-md border space-y-4 min-h-[200px]"></div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // DOM Elements
        const setupScreen = document.getElementById('setup-screen');
        const storyScreen = document.getElementById('story-screen');
        const archiveScreen = document.getElementById('archive-screen');
        const mainNav = document.getElementById('main-nav');
        const startButton = document.getElementById('start-button');
        const loadButton = document.getElementById('load-button');
        const fileLoader = document.getElementById('file-loader');
        const storyLogDiv = document.getElementById('story-log');
        const choicesContainer = document.getElementById('choices-container');
        const customInput = document.getElementById('custom-input');
        const customSubmitButton = document.getElementById('custom-submit-button');
        const saveButton = document.getElementById('save-button');
        const expandStoryButton = document.getElementById('expand-story-button');
        const summarizeButton = document.getElementById('summarize-button');
        const generateFullPlotButton = document.getElementById('generate-full-plot-button');
        const loader = document.getElementById('loader');
        const modal = document.getElementById('modal');
        const modalContentArea = document.getElementById('modal-content-area');
        const summaryStatus = document.getElementById('summary-status');

        const allViews = [setupScreen, storyScreen, archiveScreen];
        
        const setupOptions = {
            'main-genre': { elementId: 'main-genre-options', options: ['판타지', '무협', '현대판타지', '로맨스 판타지', '게임', '아포칼립스'] },
            'sub-genre': { elementId: 'sub-genre-options', options: ['정통', '퓨전', '아카데미물', '책빙의', '성좌물', '탑등반물'] },
            'protagonist-type': { elementId: 'protagonist-type-options', options: ['회귀자', '환생자', '빙의자', '차원이동자', '시한부', '일반인'] },
            'protagonist-trait': { elementId: 'protagonist-trait-options', options: ['먼치킨 재능', '상태창', '히든 피스', '망나니', '악역', '고인물'] },
            'world-bg': { elementId: 'world-bg-options', options: ['중세', '근대', '현대', '가상현실', '멸망 이후', '무림'] },
            'world-system': { elementId: 'world-system-options', options: ['마법', '정령', '신성력', '무공', '초능력', '던전/게이트'] }
        };

        let storyLog = [];
        let expandedStories = {};
        let storySummary = "";
        let fullPlot = "";

        function showView(viewId) {
            allViews.forEach(view => view.classList.add('hidden'));
            document.getElementById(viewId).classList.remove('hidden');

            const buttons = document.querySelectorAll('.nav-button');
            buttons.forEach(button => {
                button.classList.remove('active');
                if (button.getAttribute('onclick').includes(viewId)) {
                    button.classList.add('active');
                }
            });

            if (viewId === 'archive-screen') {
                populateArchive();
            }
        }

        function populateArchive() {
            const plotDiv = document.getElementById('archive-full-plot');
            const logDiv = document.getElementById('archive-story-log');

            plotDiv.textContent = fullPlot || "- 전체 줄거리가 아직 정해지지 않았습니다. -";
            logDiv.innerHTML = '';

            if (storyLog.length === 0) {
                logDiv.textContent = "- 아직 기록된 스토리가 없습니다. -";
                return;
            }

            storyLog.forEach((entry, index) => {
                const container = document.createElement('div');
                const p = document.createElement('p');
                p.innerHTML = `<strong class="font-semibold text-gray-800">${index + 1}. ${entry}</strong>`;
                container.appendChild(p);

                if (expandedStories[index]) {
                    const expandedP = document.createElement('p');
                    expandedP.textContent = expandedStories[index];
                    expandedP.className = "text-sm text-gray-600 pl-4 mt-2 border-l-2 border-sky-200 whitespace-pre-wrap";
                    container.appendChild(expandedP);
                }
                logDiv.appendChild(container);
            });
        }

        function showModal(contentHtml) {
            modalContentArea.innerHTML = contentHtml;
            modal.classList.remove('hidden');
        }

        function closeModal() {
            modal.classList.add('hidden');
        }

        function showAlert(message) {
            const content = `<p class="mb-6 text-lg text-gray-800 text-center">${message}</p><div class="text-center"><button onclick="closeModal()" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-8 rounded-lg transition-colors">확인</button></div>`;
            showModal(content);
        }

        modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });

        function renderSetupOptions() {
            for (const key in setupOptions) {
                const category = setupOptions[key];
                const container = document.getElementById(category.elementId);
                category.options.forEach((option, index) => {
                    const optionId = `${key}-${index}`;
                    const div = document.createElement('div');
                    div.innerHTML = `<input type="checkbox" id="${optionId}" name="${key}" value="${option}" class="hidden peer"><label for="${optionId}" class="block w-full text-center p-3 border rounded-lg cursor-pointer text-sm peer-checked:bg-sky-500 peer-checked:text-white peer-checked:border-sky-500 hover:bg-gray-100 transition-colors">${option}</label>`;
                    container.appendChild(div);
                });
            }
        }
        
        async function callGeminiAPI(prompt, { expectJson = false, task = 'choice' } = {}) {
            loader.classList.remove('hidden');
            if (expectJson) choicesContainer.innerHTML = '';
            
            const apiKey = "AIzaSyAcFrrcZU3z8sRPWhQ3SLNFh3OGdoeV2xA";
            
            if (apiKey === "여기에_AI_스튜디오에서_발급받은_API_키를_붙여넣으세요") {
                showAlert("API 키가 설정되지 않았습니다. 스크립트에서 API 키를 입력해주세요.");
                loader.classList.add('hidden');
                return expectJson ? [] : "오류: API 키가 없습니다.";
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const systemPrompts = {
                choice: `당신은 개연성을 중시하는 웹소설 작가입니다. 주어진 이야기의 '바로 다음'에 일어날 법한, 가장 자연스러운 사건 선택지 3개를 제안해야 합니다. 절대로 갑작스럽게 스토리를 비약시키지 마세요. 예를 들어, 이제 막 환생한 어린 주인공에게 갑자기 세계를 구하거나 엄청난 명성을 얻는 선택지를 주면 안 됩니다. 주인공의 현재 상황과 능력에 맞는, 점진적이고 현실적인 성장의 과정을 그릴 수 있는 선택지를 제시해야 합니다. 전체 줄거리가 주어진 경우, 그 흐름을 따르되 반드시 단계적인 전개를 거쳐야 합니다. 답변은 반드시 JSON 배열 형식이어야 합니다. 예: ["선택지 1", "선택지 2", "선택지 3"]`,
                expansion: `당신은 뛰어난 웹소설 작가입니다. 주어진 이야기의 맥락과 사용자의 연출 요구사항을 파악하여, 한 편의 완성도 높은 장면으로 만들어주세요. 장면을 묘사할 때, 등장인물의 심리를 보여주는 '독백', 관계와 스토리를 진전시키는 '캐릭터 간의 대화'를 적극적으로 추가해주세요. 필요하다면 '쿵!', '스르륵' 같은 '의성어/의태어'를 사용하여 생동감을 더해주세요. 특히 대화의 비중을 높여 이야기가 지루하지 않게 만들어야 합니다.`,
                summary: `당신은 웹소설 전문 편집자입니다. 주어진 줄거리 전체를 분석하여, 핵심 설정, 주요 등장인물, 그리고 지금까지 일어난 핵심 사건들을 간결하게 요약해주세요. 이 요약본은 AI가 앞으로의 이야기를 쓸 때 참고할 자료이므로, 맥락을 이해하는 데 중요한 정보는 빠뜨리지 마세요.`,
                plot_generation: `당신은 유능한 웹소설 기획자입니다. 주어진 소설의 상세한 1화 내용을 바탕으로, 앞으로 펼쳐질 이야기의 전체 줄거리(시놉시스)를 작성해주세요. 기승전결(도입, 전개, 위기, 절정, 결말) 구조에 따라 핵심 사건들을 순서대로 나열하여 흥미로운 이야기의 뼈대를 만들어주세요.`
            };

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemPrompts[task] }] }
            };

            if (expectJson) {
                payload.generationConfig = { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { type: "STRING" } } };
            }

            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) {
                    const errorBody = await response.json();
                    console.error("API Error Body:", errorBody);
                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) throw new Error("API 응답이 비어있습니다.");
                return expectJson ? JSON.parse(text) : text;
            } catch (error) {
                console.error("Gemini API call failed:", error);
                showAlert(`API 호출에 실패했습니다: ${error.message}`);
                return expectJson ? [] : "오류: 이야기를 생성할 수 없습니다.";
            } finally {
                loader.classList.add('hidden');
            }
        }

        function displayChoices(choices) {
            choicesContainer.innerHTML = '';
            choices.forEach(choice => {
                const button = document.createElement('button');
                button.textContent = choice;
                button.className = "w-full text-left p-4 bg-white border-2 border-gray-300 rounded-lg hover:bg-sky-100 hover:border-sky-500 focus:outline-none focus:ring-2 focus:ring-sky-500 transition-all transform hover:scale-101";
                button.onclick = () => handleChoice(choice);
                choicesContainer.appendChild(button);
            });
        }
        
        function updateStoryLog() {
            storyLogDiv.innerHTML = '';
            storyLog.forEach((entry, index) => {
                const entryContainer = document.createElement('div');
                entryContainer.className = "flex items-start justify-between group py-1";
                const textContainer = document.createElement('div');
                textContainer.className = "flex-grow";
                const p = document.createElement('p');
                p.textContent = `${index + 1}. ${entry}`;
                p.className = "whitespace-pre-wrap";
                textContainer.appendChild(p);

                if (expandedStories[index]) {
                    const expandedP = document.createElement('p');
                    expandedP.textContent = expandedStories[index];
                    expandedP.className = "text-sm text-gray-600 pl-4 mt-1 border-l-2 border-sky-200 whitespace-pre-wrap";
                    textContainer.appendChild(expandedP);
                }
                entryContainer.appendChild(textContainer);
                if (index > 0) {
                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = '삭제';
                    deleteButton.className = "ml-4 text-red-500 hover:text-red-700 text-sm font-semibold opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0";
                    deleteButton.onclick = () => showDeleteConfirmation(index);
                    entryContainer.appendChild(deleteButton);
                }
                storyLogDiv.appendChild(entryContainer);
            });
            storyLogDiv.scrollTop = storyLogDiv.scrollHeight;
        }
        
        window.showDeleteConfirmation = (index) => {
            const content = `<p class="text-center mb-6">정말로 ${index + 1}화부터 그 이후의 모든 내용을 삭제하시겠습니까?<br>이 작업은 되돌릴 수 없습니다.</p><div class="flex justify-center gap-4"><button onclick="confirmDeleteLog(${index})" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg">삭제</button><button onclick="closeModal()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg">취소</button></div>`;
            showModal(content);
        };

        window.confirmDeleteLog = async (index) => {
            closeModal();
            storyLog.splice(index);
            Object.keys(expandedStories).forEach(key => { if (key >= index) delete expandedStories[key]; });
            storySummary = "";
            fullPlot = "";
            summaryStatus.classList.add('hidden');
            generateFullPlotButton.classList.add('hidden');
            updateStoryLog();
            await generateNextChoices();
        };

        async function generateNextChoices() {
            if (storyLog.length === 0) { choicesContainer.innerHTML = ''; return; }
            let prompt = "";
            const recentLogs = storyLog.slice(-2).join('\n');

            if (fullPlot) {
                 prompt = `[전체 줄거리]:\n${fullPlot}\n\n[최근 사건]:\n${recentLogs}\n\n[요청]: 위 전체 줄거리의 흐름에 맞춰, 최근 사건 다음에 일어날 흥미로운 이벤트 선택지 3개를 제안해주세요.`;
            } else if (storySummary) {
                prompt = `[지금까지의 요약]:\n${storySummary}\n\n[최근 사건]:\n${recentLogs}\n\n[요청]: 위 내용에 이어질 다음 사건 선택지 3개를 제안해주세요.`;
            } else {
                prompt = `[현재까지의 이야기]:\n${storyLog.join('\n')}\n\n[요청]: 위 내용에 이어질 다음 사건 선택지 3개를 제안해주세요.`;
            }
            const newChoices = await callGeminiAPI(prompt, { expectJson: true, task: 'choice' });
            displayChoices(newChoices);
        }

        async function handleChoice(choice) {
            storyLog.push(choice);
            updateStoryLog();
            await generateNextChoices();
        }

        startButton.addEventListener('click', async () => {
            const selectedOptions = {};
            let hasSelection = false;
            for (const key in setupOptions) {
                const checked = document.querySelectorAll(`input[name="${key}"]:checked`);
                if (checked.length > 0) {
                    hasSelection = true;
                    selectedOptions[key] = Array.from(checked).map(cb => cb.value);
                }
            }
            if (!hasSelection) {
                showAlert('하나 이상의 초기 설정을 선택해주세요!');
                return;
            }
            
            mainNav.classList.remove('hidden');
            showView('story-screen');
            
            let initialStory = "초기 설정: ";
            for (const key in selectedOptions) {
                initialStory += `${selectedOptions[key].join('/')}, `;
            }
            initialStory = initialStory.slice(0, -2) + ". 이 설정으로 이야기가 시작됩니다.";

            storyLog = [initialStory];
            expandedStories = {};
            storySummary = "";
            fullPlot = "";
            generateFullPlotButton.classList.add('hidden');
            updateStoryLog();
            
            const prompt = `${initialStory} 이 설정으로 시작하는 웹소설의 첫번째 사건에 대한 선택지 3개를 제시해주세요.`;
            const choices = await callGeminiAPI(prompt, { expectJson: true, task: 'choice' });
            displayChoices(choices);
        });

        loadButton.addEventListener('click', () => {
            fileLoader.click();
        });

        fileLoader.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) { return; }

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const content = event.target.result;
                    parseAndLoadState(content);
                } catch (err) {
                    showAlert('파일을 읽는 도중 오류가 발생했습니다: ' + err.message);
                }
            };
            reader.readAsText(file);
            e.target.value = ''; // Reset file input
        });

        function parseAndLoadState(content) {
            // Reset state
            let tempLog = [];
            let tempExpanded = {};
            let tempPlot = "";
            let tempSummary = "";
            
            // Extract Full Plot
            const plotMatch = content.match(/\[전체 줄거리\]\n([\s\S]*?)\n\n================================/);
            if (plotMatch && plotMatch[1].trim() !== "- 전체 줄거리가 아직 정해지지 않았습니다. -") {
                tempPlot = plotMatch[1].trim();
            }

            // Extract Summary
            const summaryMatch = content.match(/\[AI용 내용 요약본\]\n([\s\S]*?)\n\n================================/);
            if (summaryMatch) {
                tempSummary = summaryMatch[1].trim();
            }

            // Extract Logs and Expansions
            const logRegex = /\[(\d+)화 요약\]\n([\s\S]*?)\n\n(?:\[\d+화 상세\]\n([\s\S]*?)\n\n--------------------------------\n\n)?/g;
            let match;
            while ((match = logRegex.exec(content)) !== null) {
                const logIndex = parseInt(match[1], 10) - 1;
                const logSummary = match[2].trim();
                const logExpansion = match[3] ? match[3].trim() : null;

                tempLog[logIndex] = logSummary;
                if (logExpansion) {
                    tempExpanded[logIndex] = logExpansion;
                }
            }

            if (tempLog.length === 0) {
                showAlert('유효한 스토리 로그를 파일에서 찾을 수 없습니다.');
                return;
            }

            // Apply loaded state
            storyLog = tempLog;
            expandedStories = tempExpanded;
            fullPlot = tempPlot;
            storySummary = tempSummary;
            
            // Update UI
            mainNav.classList.remove('hidden');
            showView('story-screen');
            updateStoryLog();

            if (expandedStories[0]) {
                generateFullPlotButton.classList.remove('hidden');
            }
            if (storySummary) {
                summaryStatus.textContent = "✔ 요약본이 생성되어 AI의 기억력으로 사용됩니다.";
                summaryStatus.classList.remove('hidden');
            }

            showAlert('작업을 성공적으로 불러왔습니다!');
            generateNextChoices();
        }
        
        customSubmitButton.addEventListener('click', async () => {
            const customText = customInput.value.trim();
            if (customText) {
                await handleChoice(customText);
                customInput.value = '';
            }
        });
        
        customInput.addEventListener('keydown', (event) => { if (event.key === 'Enter') customSubmitButton.click(); });
        
        summarizeButton.addEventListener('click', async () => {
            if (storyLog.length < 3) { showAlert('요약하기에는 이야기가 너무 짧습니다.'); return; }
            let fullText = storyLog.map((entry, index) => `${index + 1}. ${entry}\n${expandedStories[index] ? `(상세 내용) ${expandedStories[index]}\n` : ''}`).join('');
            const prompt = `다음은 웹소설의 전체 줄거리입니다. 이 내용을 요약해주세요:\n\n${fullText}`;
            storySummary = await callGeminiAPI(prompt, { task: 'summary' });
            summaryStatus.textContent = "✔ 요약본이 생성되어 AI의 기억력으로 사용됩니다.";
            summaryStatus.classList.remove('hidden');
            showAlert('스토리 요약이 완료되었습니다!');
        });

        generateFullPlotButton.addEventListener('click', async () => {
            if(fullPlot){
                showFullPlotEditor(fullPlot);
                return;
            }
            if (!expandedStories[0]) { showAlert('1화를 먼저 부풀려야 전체 스토리를 생성할 수 있습니다.'); return; }
            
            const prompt = `[소설의 1화 내용]:\n${expandedStories[0]}\n\n[요청]: 위 1화 내용을 바탕으로 소설의 전체 줄거리(시놉시스)를 작성해주세요.`;
            const plot = await callGeminiAPI(prompt, { task: 'plot_generation'});
            fullPlot = plot;
            showFullPlotEditor(fullPlot);
        });
        
        window.showFullPlotEditor = (plotText) => {
             const content = `<h3 class="text-xl font-bold mb-4 text-center">전체 스토리 편집</h3><textarea id="full-plot-textarea" class="w-full h-96 p-2 border rounded-md">${plotText}</textarea><div class="flex justify-center gap-4 mt-6"><button onclick="saveFullPlot()" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-6 rounded-lg">줄거리 확정</button><button onclick="closeModal()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg">취소</button></div>`;
            showModal(content);
        };

        window.saveFullPlot = async () => {
            fullPlot = document.getElementById('full-plot-textarea').value;
            closeModal();
            showAlert('전체 줄거리가 저장되었습니다. 이제부터 AI는 이 줄거리를 따라갑니다.');
            await generateNextChoices();
        };

        expandStoryButton.addEventListener('click', () => {
            if (storyLog.length === 0) { showAlert('부풀릴 스토리가 없습니다.'); return; }
            let listHtml = storyLog.map((log, index) => `<button onclick="showExpansionOptions(${index})" class="w-full text-left p-3 mb-2 border rounded-md hover:bg-gray-100">${index + 1}. ${log.substring(0, 50)}...${expandedStories[index] ? ' (부풀림)' : ''}</button>`).join('');
            const content = `<h3 class="text-xl font-bold mb-4 text-center">부풀릴 화 선택</h3><div class="space-y-2">${listHtml}</div><div class="text-center mt-6"><button onclick="closeModal()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg">취소</button></div>`;
            showModal(content);
        });

        window.showExpansionOptions = (index) => {
            const content = `<h3 class="text-xl font-bold mb-4 text-center">${index + 1}화 연출 키워드</h3><p class="text-center text-gray-600 mb-4">이 장면에 추가하고 싶은 키워드나 요구사항을 입력하세요. (선택사항)</p><input id="expansion-keyword" type="text" class="w-full p-2 border rounded-md mb-6" placeholder="예: 숨겨진 능력 발현, 새로운 인물 등장"><div class="flex justify-center gap-4"><button onclick="executeExpansion(${index})" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-6 rounded-lg">부풀리기 실행</button><button onclick="closeModal()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg">취소</button></div>`;
            showModal(content);
        };

        window.executeExpansion = async (index) => {
            const keyword = document.getElementById('expansion-keyword').value.trim();
            closeModal();
            let prompt;
            const context = storySummary ? `[지금까지의 요약]:\n${storySummary}` : `[이전 줄거리]:\n${storyLog.slice(0, index).join('\n')}`;
            const keywordInstruction = keyword ? `\n\n[사용자 연출 키워드]: "${keyword}"\n이 키워드를 반드시 이야기에 반영해주세요.` : "";

            if (expandedStories[index]) {
                prompt = `${context}\n\n[기존 장면]:\n"${expandedStories[index]}"\n\n[요청]: 위 장면의 내용을 기반으로, 분량을 1.5배에서 2배로 늘려 훨씬 더 상세하고 풍부한 이야기로 만들어주세요.${keywordInstruction}`;
            } else {
                prompt = `${context}\n\n[대상 문장]:\n"${storyLog[index]}"\n\n[요청]: 위 문장을 한 편의 상세한 장면으로 만들어주세요.${keywordInstruction}`;
            }
            
            const expandedText = await callGeminiAPI(prompt, { task: 'expansion' });
            showExpansionEditor(index, expandedText);
        };

        window.showExpansionEditor = (index, text) => {
            const content = `<h3 class="text-xl font-bold mb-4 text-center">${index + 1}화 스토리 확장</h3><textarea id="expansion-textarea" class="w-full h-64 p-2 border rounded-md">${text}</textarea><div class="flex justify-center gap-4 mt-6"><button onclick="confirmExpansion(${index})" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-6 rounded-lg">선택</button><button onclick="closeModal()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg">취소</button></div>`;
            showModal(content);
        };
        
        window.confirmExpansion = async (index) => {
            expandedStories[index] = document.getElementById('expansion-textarea').value;
            updateStoryLog();
            closeModal();

            if (index === 0 && expandedStories[0]) {
                generateFullPlotButton.classList.remove('hidden');
            }

            if (index === storyLog.length - 1) {
                await generateNextChoices();
            }
        };

        saveButton.addEventListener('click', () => {
            if (storyLog.length === 0) { showAlert('저장할 스토리가 없습니다.'); return; }
            let fullText = "소설 짜깁기 v.1 - 줄거리\ndesigned by 유성열\n\n================================\n\n";
            
            fullText += `[전체 줄거리]\n${fullPlot || "- 전체 줄거리가 아직 정해지지 않았습니다. -"}\n\n================================\n\n`;
            if (storySummary) {
                fullText += `[AI용 내용 요약본]\n${storySummary}\n\n================================\n\n`;
            }

            storyLog.forEach((entry, index) => {
                fullText += `[${index + 1}화 요약]\n${entry}\n\n`;
                if(expandedStories[index]) {
                    fullText += `[${index + 1}화 상세]\n${expandedStories[index]}\n\n--------------------------------\n\n`;
                }
            });
            const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'novel_plot_final.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        renderSetupOptions();
    </script>
</body>
</html>

